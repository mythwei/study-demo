package cn.think.in.java.two;

/**
 * java 内存模型：
 * 单线程下会重排序。
 * 下面这段程序再 -server 模式下会优化代码（重排序），导致永远死循环。
 */
public class JMMDemo {

  static volatile boolean ready;
  static int num;

  static class ReaderThread extends Thread {

    public void run() {
      while (!ready) {
        ;
      }
      System.out.println(num);

    }
  }

  public static void main(String[] args) throws InterruptedException {
    new ReaderThread().start();
    Thread.sleep(1000);
    num = 32;
    ready = true;
    Thread.sleep(1000);
  }

}

/**
 * 那些不建议使用的并发方法
 1. stop 太过于暴力，强行把执行到一半的线程终止，引起数据不一致。可使用一个条件来代替此功能，比如设置一个变量，如果这个变量是ture 则跳出循环，结束线程的执行

 2. 有关线程中断的三个方法：
 2.1 Thread.interrupt 中断线程，也就是设置中断标记
 2.2 Thread.isInterrupted 判断释放中断
 2.3 static boolean Thread interrupted 判断是否中断，并清楚当前中断状态。
 在java 中，线程中断是一种重要的线程协作机制。可以用来代替 stop方法，严格来讲， 线程中断并不会使线程立即退出，
 而是给线程发一个通知，告知目标线程，有人希望你退出了。而什么时候退出，完全由线程自己自行决定，避免了stop 的问题。
 但是该方法只是设置标记，所以需要自己判断状态然后跳出循环之类的结束线程运行。

 3. suspend 挂起方法，  resume 继续执行方法：一对相反的操作。但是是废弃方法。因为挂起后并不会释放任何锁资源，直到 resume 执行才能恢复。可使用 wait notify 加 flag 变量来控制暂停和继续。

 4. join 等待线程结束 yieid 谦让出时间片；一个线程的输入可能非常依赖于另一个线程的输出，因此，此时，这个线程就要等待依赖线程执行完毕，才能继续执行。join 可实现此功能。实际上就是让当前线程 wait 再目标线程上，目标线程执行完毕会notifyAll。

 yieid 会让出时间片，但是是随机的。如果你觉得一个线程不是很重要，那就可以适当的调用该方法，给予其他线程更多的机会。


 cpu 高速缓存 内存
 多个cpu缓存导致出现 缓存一致性问题

 解决一致性问题：定义了一些协议（在读写时）：MSI，MESI，MOSI，Synapse，Firefly，Dragon Protocol。

 内存模式定义：可以理解为在特定的操作协议下，对特定的内存或告诉缓存进行访问读写的过程抽象，不同架构的物理机器可以拥有不一样的内存模型。





 Java 虚拟机的内存模型，抽象了多种处理器和操作系统还有MESI等缓存一致性协议的操作过程。

 为了压榨cpu性能，cpu 除了增加缓存，还会使用流水线执行，为了优化流水线执行的过程，就需要对代码进行乱序执行优化（为了不让流水线中断）。

 Java 虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。



 JMM（Java Memory Mode），Java 虚拟机规范定义了一种JMM来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java 程序 在各种平台下都能达到一致的内存访问效果。
 在此之前，主流程序语言（c/c++）直接使用物理硬件和操作系统的内存模型，导致代码没有移植性。1.5之后，Java 的内存模型已经成熟和完善了。定义Java 内存模型是件
 困难的事情，既要严谨，又要宽松。


 Java 内存模型的主要目标是定义**程序中各个变量的访问规则**，即在虚拟机中将变量存储到内存和从内存中取出变量（不包括局部变量和方法参数）的底层细节。


 具体细节：JMM 规定了所有的变量都存储在主内存（类似内存芯片）中， 每个线程都有自己的工作内存（类似CPU 高速缓存），工作内存拷贝（volatile 也拷贝，只是顺序被控制）
 主内存数据。线程只操作自己的工作内存，然后刷新到主内存，不同线程的工作内存是完全隔离的，因此，刷新到主内存是线程与线程的通信方式。

 注意：JMM 的内存和 Java 堆，栈，方法区不是同一个概念。如果硬是要勉强对应，那么，主内存可以对应Java堆中的对象实例，工作内存对应虚拟机栈中的部分区域。从更低层次说，
 主内存就直接对应于物理硬件的内存，而为了性能，虚拟机或者CPU会将工作内存放在寄存器和高速缓存中。


 内存有8种操作：lock，unlock，read,load,use,assign,store,write.每个操作都是原子的。
 多个操作之间都有着一定的规则，然后加上关于 volatile 的规定（因为 volatile 非常特殊），确定了 Java 程序种哪些内存访问操作在并发下是安全的。

 volatile 可以说是Java 虚拟机提供的最轻量级的同步机制。但不容易完全理解他。

 volatile 变量在各个线程中都是一致的。但不代表基于 volatile 的运算就是并发安全的。

 i++;
 1. i == 1;
 2. i = i + 1;
 3. i = 2;

 当多个线程读取到正确的值，但每个线程都对该值进行操作，然后刷新主存，导致错误。也就是说，volatile 只保证每个线程读取到值是最新的。

 */
